#!/usr/bin/env python3

import sys
import datetime

mya_url = 'https://epicsweb.jlab.org/myquery/interval'
mya_fmt = '%Y-%m-%dT%H:%M:%S'
usr_fmt = mya_fmt

rcdb_connection = 'mysql://rcdb@clasdb.jlab.org/rcdb'
rcdb_provider = None

def get_cli():
    global rcdb_connection
    global user_fmt
    import argparse
    cli = argparse.ArgumentParser(description='A Simplest Mya Plotter', epilog='For example, for the HWP:  myaplt -s -m history -b 4013 -e 4014 IGL1I00OD16_16,HWP')
    cli.add_argument('pv', help='pv[,alias]', nargs='+')
    cli.add_argument('-b', help='begin date or RCDB run number (default=yesterday)', default=datetime.datetime.now()-datetime.timedelta(days=-1))
    cli.add_argument('-e', help='end date or RCDB run number (default=now)', default=datetime.datetime.now())
    cli.add_argument('-m', help='Mya deployment (default=ops)', default='ops', choices=['ops','history','dev'])
    cli.add_argument('-r', help=f'RCDB connection string (default={rcdb_connection})', default=rcdb_connection, metavar='RCDB_CONNECTION')
    cli.add_argument('-d', help='date format (default=%s)'%mya_fmt.replace('%','%%'), default=mya_fmt)
    cli.add_argument('-v', help='increase verbosity', action='count', default=0)
    cli.add_argument('-s', help='use step plotting style', default=False, action='store_true')
    args = cli.parse_args(sys.argv[1:])
    args.alias = [ pv.split(',').pop() for pv in args.pv ]
    args.pv = [ pv.split(',').pop(0) for pv in args.pv ]
    rcdb_connection = args.r
    user_fmt = args.d
    return cli,args

def get_rcdb_datetime(run):
    # Get a datetime range based on a run in RCDB:
    global rcdb_provider
    if rcdb_provider is None:
        import rcdb
        rcdb_provider = rcdb.RCDBProvider(rcdb_connection)
    try:
        b = rcdb_provider.get_condition(int(run), 'run_start_time')
        e = rcdb_provider.get_condition(int(run), 'run_end_time')
        if not b is None: b = b.value
        if not e is None: e = e.value
        return [b,e]
    except AttributeError:
        return None

def get_rcdb_runs(rmin, rmax):
    global rcdb_provider
    if rcdb_provider is None:
        import rcdb
        rcdb_provider = rcdb.RCDBProvider(rcdb_connection)
    run = rcdb_provider.get_next_run(rmin-1)
    while run.number < rmax:
        r = rcdb_provider.get_next_run(run)
        if r is None:
            run.number += 1
        else:
            run = r
            d = get_rcdb_datetime(run.number)
            if d is not None:
                yield [run.number , d[0]]

def get_datetime(value, side=0):
    # Get a datetime by parsing a string, or from a run in RCDB:
    if type(value) is datetime.datetime:
        return value
    elif type(value) is str and value.isdigit():
        return get_datetime(int(value))
    elif type(value) is str:
        try: return datetime.datetime.strptime(value, user_fmt)
        except ValueError: return None
    elif type(value) is int:
        return get_rcdb_datetime(value)[side]

def get_mya_df(pv, alias, args):
    # Retrive one dataframe from Mya for one PV:
    import requests
    b = get_datetime(args.b,0)
    e = get_datetime(args.e,1)
    if b is None: sys.exit('ERROR:  Invalid -b:  '+args.b)
    if e is None: sys.exit('ERROR:  Invalid -e:  '+args.e)
    b = b.strftime(mya_fmt)
    e = e.strftime(mya_fmt)
    url = mya_url+'?p=1&a=1&d=1&c=%s&m=%s&b=%s&e=%s' % (pv, args.m, b, e)
    if args.v>2: print(url)
    requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)
    retries = requests.adapters.Retry(total=10, backoff_factor=0.1, status_forcelist=[500,502,503,504])
    session = requests.Session()
    session.mount(url, requests.adapters.HTTPAdapter(max_retries=retries))
    result = session.get(url, timeout=1.0, verify=False)
    import pandas
    df = pandas.DataFrame(result.json().get('data'))
    if args.v>1: print(df)
    df['d'] = [ datetime.datetime.fromtimestamp(int(x)/1000) for x in df['d'] ]
    if args.v>0: print(df)
    df.rename(columns={'v':alias}, inplace=True)
    return df

def get_mya_dfs(args):
    # Spawn Mya query threads, one per PV:
    import concurrent.futures
    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        futures = []
        for pv,alias in zip(args.pv, args.alias):
            if args.v>1: print('INFO:     Reading %s from Mya ...'%pv)
            futures.append(executor.submit(get_mya_df, pv, alias, args))
        for f in futures:
            concurrent.futures.wait([f])
            if f.exception() is not None:
                sys.exit(f.exception())
            yield f.result()

def plot(df, args):
    import pandas
    import matplotlib.pyplot as plt
    import matplotlib.dates as dates
    from matplotlib.ticker import MaxNLocator
    plt.gca().xaxis.set_major_formatter(dates.DateFormatter('%m/%d/%Y'))
    plt.gca().xaxis.set_major_locator(dates.DayLocator())
    for alias in args.alias:
        if args.s: plt.step(df['d'], df[alias], where='pre')
        else:      plt.plot(df['d'], df[alias])
    plt.gcf().autofmt_xdate()
    plt.gca().xaxis.set_major_locator(MaxNLocator(nbins=10))
    plt.ylabel(args.alias[0])

def ticks(df, rmin, rmax):
    n = 40
    bins = []
    vals = []
    labels = []
    t0 = df['d'][0]
    t1 = df['d'][len(df['d'])-1]
    for i,(r,t) in enumerate(filter(lambda x: x[1], get_rcdb_runs(rmin,rmax))):
        for j in range(40):
            t3 = t0 + 1.0/n*j*(t1-t0)
            if t > t3 and t < t3 + 1.0/n*(t1-t0):
                fraction = (t-t0) / (t1-t0)
                absolute = t0 + fraction*(t1-t0)
                if fraction>=0 and fraction<=1 and j not in bins:
                    bins.append(j)
                    vals.append(absolute)
                    labels.append(r)
    import matplotlib.pyplot as plt
    ax1 = plt.gcf().get_axes()[0]
    ax2 = ax1.twiny()
    ax2.set_xlim(ax1.get_xlim())
    ax2.set_xticks(vals)
    ax2.set_xticklabels(labels)
    ax2.set_xlabel('Run Number')
    ax2.tick_params(axis='x', labelrotation=90)

if __name__ == '__main__':
    cli,args = get_cli()
    if args.v > 3: print(args)
    import pandas
    dfs = list(get_mya_dfs(args))
    df = pandas.concat(dfs).sort_values('d')
    plot(df, args)
    if args.b.isdigit() and args.e.isdigit():
        ticks(df, int(args.b), int(args.e))
    import matplotlib.pyplot as plt
    plt.show()

