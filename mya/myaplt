#!/usr/bin/env python3

import sys
import datetime

mya_url = 'https://epicsweb.jlab.org/myquery/interval'
mya_fmt = '%Y-%m-%dT%H:%M:%S'
usr_fmt = mya_fmt

rcdb_connection = 'mysql://rcdb@clasdb.jlab.org/rcdb'
rcdb_provider = None

def get_cli():
    global rcdb_connection
    global user_fmt
    import argparse
    cli = argparse.ArgumentParser(description='A Simplest Mya Plotter', epilog='For example, for the HWP:  myaplt -s -m history -b 4013 -e 4014 IGL1I00OD16_16,HWP')
    cli.add_argument('pv', help='pv[,alias]', nargs='+')
    cli.add_argument('-b', help='begin date or RCDB run number (default=yesterday)', default=datetime.datetime.now()-datetime.timedelta(days=-1))
    cli.add_argument('-e', help='end date or RCDB run number (default=now)', default=datetime.datetime.now())
    cli.add_argument('-m', help='Mya deployment (default=ops)', default='ops', choices=['ops','history','dev'])
    cli.add_argument('-r', help=f'RCDB connection string (default={rcdb_connection})', default=rcdb_connection, metavar='RCDB_CONNECTION')
    cli.add_argument('-d', help='date format (default=%s)'%mya_fmt.replace('%','%%'), default=mya_fmt)
    cli.add_argument('-v', help='increase verbosity', action='count', default=0)
    cli.add_argument('-s', help='use step plotting style', default=False, action='store_true')
    cli.add_argument('-c', help='calibrate runs with a simple deadband (first pv only)', default=None, type=float)
    args = cli.parse_args(sys.argv[1:])
    args.alias = [ pv.split(',').pop() for pv in args.pv ]
    args.pv = [ pv.split(',').pop(0) for pv in args.pv ]
    rcdb_connection = args.r
    user_fmt = args.d
    return cli,args

def get_rcdb_datetime(run):
    # Get a datetime range based on a run in RCDB:
    global rcdb_provider
    if rcdb_provider is None:
        import rcdb
        rcdb_provider = rcdb.RCDBProvider(rcdb_connection)
    try:
        b = rcdb_provider.get_condition(int(run), 'run_start_time')
        e = rcdb_provider.get_condition(int(run), 'run_end_time')
        if not b is None: b = b.value
        if not e is None: e = e.value
        return [b,e]
    except AttributeError:
        return None

def get_rcdb_datetimes(rmin, rmax):
    # Get a list of runs and their start times from RCDB:
    global rcdb_provider
    if rcdb_provider is None:
        import rcdb
        rcdb_provider = rcdb.RCDBProvider(rcdb_connection)
    run = rcdb_provider.get_prev_run(rmin)
    while run.number < rmax:
        r = rcdb_provider.get_next_run(run)
        if r is None:
            run.number += 1
        else:
            run = r
            d = get_rcdb_datetime(run.number)
            if d is not None:
                yield [run.number , d[0]]

def get_datetime(value, side=0):
    # Get a datetime by parsing a string, or from a run in RCDB:
    if type(value) is datetime.datetime:
        return value
    elif type(value) is int:
        return get_rcdb_datetime(value)[side]
    elif type(value) is str:
        if value.isdigit():
            return get_datetime(int(value))
        elif type(value) is str:
            try: return datetime.datetime.strptime(value, user_fmt)
            except ValueError: return None
    else:
        raise TypeError(f'Invalid type ({value})')

def get_mya_df(url):
    # Put a Mya query into a dataframe:
    import requests
    requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)
    retries = requests.adapters.Retry(total=10, backoff_factor=0.1, status_forcelist=[500,502,503,504])
    session = requests.Session()
    session.mount(url, requests.adapters.HTTPAdapter(max_retries=retries))
    result = session.get(url, timeout=1.0, verify=False)
    import pandas
    df = pandas.DataFrame(result.json().get('data'))
    df['d'] = [ datetime.datetime.fromtimestamp(int(x)/1000) for x in df['d'] ]
    return df

def get_mya_pv_df(pv, alias, args):
    # Retrieve one dataframe from Mya for one PV:
    b = get_datetime(args.b,0)
    e = get_datetime(args.e,1)
    if b is None: sys.exit('ERROR:  Invalid -b:  '+args.b)
    if e is None: sys.exit('ERROR:  Invalid -e:  '+args.e)
    b = b.strftime(mya_fmt)
    e = e.strftime(mya_fmt)
    url = mya_url+'?p=1&a=1&d=1&c=%s&m=%s&b=%s&e=%s' % (pv, args.m, b, e)
    if args.v>0: print(url)
    df = get_mya_df(url)
    df.rename(columns={'v':alias}, inplace=True)
    return df

def get_mya_pv_dfs(args):
    # Spawn Mya query threads, one per PV:
    import concurrent.futures
    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        futures = []
        for pv,alias in zip(args.pv, args.alias):
            futures.append(executor.submit(get_mya_pv_df, pv, alias, args))
        for f in futures:
            concurrent.futures.wait([f])
            if f.exception() is not None:
                sys.exit(f.exception())
            yield f.result()

def plot(df, args):
    import pandas
    import matplotlib.pyplot as plt
    import matplotlib.dates as dates
    from matplotlib.ticker import MaxNLocator
    plt.gca().xaxis.set_major_formatter(dates.DateFormatter('%m/%d/%Y'))
    plt.gca().xaxis.set_major_locator(dates.DayLocator())
    import numpy
    for alias in args.alias:
        if args.s: plt.step(df['d'].to_numpy(), df[alias].to_numpy(), where='post')
        else:      plt.plot(df['d'].to_numpy(), df[alias].to_numpy())
    plt.gcf().autofmt_xdate()
    plt.gca().xaxis.set_major_locator(MaxNLocator(nbins=10))
    plt.ylabel(args.alias[0])

def runticks(tmin, tmax, runs):
    # Generate nmax (at most) ticks for run numbers:
    nmax, bins = 40, []
    for i,(r,t) in enumerate(runs):
        for j in range(nmax):
            t1 = tmin + 1.0/nmax*j*(tmax-tmin)
            t2 = t1 + 1.0/nmax*(tmax-tmin)
            if t>=t1 and t<t2:
                fraction = (t-tmin) / (tmax-tmin)
                absolute = tmin + fraction*(tmax-tmin)
                if fraction>=0 and fraction<=1 and j not in bins:
                    bins.append(j)
                    yield [r,absolute]

def ticks(vals, labels):
    import matplotlib.pyplot as plt
    ax1 = plt.gcf().get_axes()[0]
    ax2 = ax1.twiny()
    ax2.set_xlim(ax1.get_xlim())
    ax2.set_xticks(vals)
    ax2.set_xticklabels(labels)
    ax2.set_xlabel('Run Number')
    ax2.tick_params(axis='x', labelrotation=90)

def calib(df, alias, deadband=0):
    val,prev_row = None,None
    for i, row in df.iterrows():
        val = row[alias]
        if prev_row is None or abs(val-prev_row[alias]) > deadband:
            print('CALIB:  ',row['run'], row['d'], val, flush=True)
        prev_row = row

if __name__ == '__main__':
    cli,args = get_cli()
    import pandas
    dfs = list(get_mya_pv_dfs(args))
    df = pandas.concat(dfs).sort_values('d')
    if args.v > 1:
        with pandas.option_context('display.max_rows', None):
            print(df, flush=True)
    if args.b.isdigit() and args.e.isdigit():
        runs = list(filter(lambda x: x[1], get_rcdb_datetimes(int(args.b),int(args.e))))
        rt = list(runticks(df['d'][0], df['d'][len(df['d'])-1], runs))
        if args.c is not None:
            x = pandas.DataFrame(data={'d':[x[1] for x in runs], 'run':[x[0] for x in runs]})
            df = pandas.concat([df,x]).sort_values('d').ffill().bfill()
            if args.v > 1:
                with pandas.option_context('display.max_rows', None):
                    print(df, flush=True)
            calib(df, args.alias[0])
#        df = df.reindex(df['d'].sort_values().index)
        plot(df, args)
        v = ticks([x[1] for x in rt], [str(x[0]) for x in rt])
    else:
        plot(df, args)
    import matplotlib.pyplot as plt
    plt.show()

